/// <reference types="node" />
import { IncomingMessage, ServerResponse } from 'http';
import { WebClientOptions } from '@slack/web-api';
import { CodedError } from './errors';
import { Logger, LogLevel } from './logger';
/**
 * InstallProvider Class.
 * @param clientId - Your apps client ID
 * @param clientSecret - Your apps client Secret
 * @param stateSecret - Used to sign and verify the generated state when using the built-in `stateStore`
 * @param stateStore - Replacement function for the built-in `stateStore`
 * @param installationStore - Interface to store and retrieve installation data from the database
 * @param authVersion - Can be either `v1` or `v2`. Determines which slack Oauth URL and method to use
 * @param logger - Pass in your own Logger if you don't want to use the built-in one
 * @param logLevel - Pass in the log level you want (ERROR, WARN, INFO, DEBUG). Default is INFO
 */
export declare class InstallProvider {
    stateStore: StateStore;
    installationStore: InstallationStore;
    private clientId;
    private clientSecret;
    private authVersion;
    private logger;
    private clientOptions;
    private authorizationUrl;
    constructor({ clientId, clientSecret, stateSecret, stateStore, installationStore, authVersion, logger, logLevel, clientOptions, authorizationUrl, }: InstallProviderOptions);
    /**
     * Fetches data from the installationStore.
     */
    authorize(source: InstallationQuery): Promise<AuthorizeResult>;
    /**
     * Returns a URL that is suitable for including in an Add to Slack button
     * Uses stateStore to generate a value for the state query param.
     */
    generateInstallUrl(options: InstallURLOptions): Promise<string>;
    /**
     * This method handles the incoming request to the callback URL.
     * It can be used as a RequestListener in almost any HTTP server
     * framework.
     *
     * Verifies the state using the stateStore, exchanges the grant in the
     * query params for an access token, and stores token and associated data
     * in the installationStore.
     */
    handleCallback(req: IncomingMessage, res: ServerResponse, options?: CallbackOptions): Promise<void>;
}
export interface InstallProviderOptions {
    clientId: string;
    clientSecret: string;
    stateStore?: StateStore;
    stateSecret?: string;
    installationStore?: InstallationStore;
    authVersion?: 'v1' | 'v2';
    logger?: Logger;
    logLevel?: LogLevel;
    clientOptions?: Omit<WebClientOptions, 'logLevel' | 'logger'>;
    authorizationUrl?: string;
}
export interface InstallURLOptions {
    scopes: string | string[];
    teamId?: string;
    redirectUri?: string;
    userScopes?: string | string[];
    metadata?: string;
}
export interface CallbackOptions {
    success?: (installation: Installation, options: InstallURLOptions, callbackReq: IncomingMessage, callbackRes: ServerResponse) => void;
    failure?: (error: CodedError, options: InstallURLOptions, callbackReq: IncomingMessage, callbackRes: ServerResponse) => void;
}
export interface StateStore {
    generateStateParam: (installOptions: InstallURLOptions, now: Date) => Promise<string>;
    verifyStateParam: (now: Date, state: string) => Promise<InstallURLOptions>;
}
export interface InstallationStore {
    storeInstallation: (installation: Installation, logger?: Logger) => Promise<void>;
    fetchInstallation: (query: InstallationQuery, logger?: Logger) => Promise<Installation>;
}
export interface Installation {
    team: {
        id: string;
        name: string;
    };
    enterprise?: {
        id: string;
        name?: string;
    };
    bot?: {
        token: string;
        scopes: string[];
        id?: string;
        userId: string;
    };
    user: {
        token?: string;
        scopes?: string[];
        id: string;
    };
    incomingWebhook?: {
        url: string;
        channel: string;
        channelId: string;
        configurationUrl: string;
    };
    appId: string | undefined;
    tokenType?: string;
}
export interface InstallationQuery {
    teamId: string;
    enterpriseId?: string;
    userId?: string;
    conversationId?: string;
}
export interface AuthorizeResult {
    botToken?: string;
    userToken?: string;
    botId?: string;
    botUserId?: string;
}
export { Logger, LogLevel } from './logger';
//# sourceMappingURL=index.d.ts.map